1. 은닉성
1-1 은닉성이란?
- 멤버변수나 메서드가 객체에 노출되지 않도록 설정하는 기법
- 객체를 사용하는 측의 실수로 인한 기능의 오작동을 방지하기 위해, 클래스 
일부를 숨기는 처리를 말한다.

1-2 적용방법
- 변수의 이름이나 메서드 이름 앞에 " 접근 한정자"를 지정한다.
- public
	-> 모든 곳에서 접근 가능하다.
	-> 일반적으로 모든 메서드 앞에 명시한다.
- private
	-> 클래스 안에서만 사용 가능하고, 객체를 통해 접근할 수 없다.
	-> 일반적으로 모든 멤버변수 앞에 명시한다.
- protected
	-> 현재 클래스 내의 다른 자원이나, 같은 패키지 안에 존재하는 
	클래스와 하위 클래스에서 접근 가능하다.
	-> 잘 사용되지 않는다.
- default
	-> 접근 한정자를 명시하지 않을 경우.
	-> 현재 클래스 내의 다른 자원이나 동일 패키지 내의 다른 
	클래스에서 접근 가능하다.
	-> 잘 사용되지 않는다.

1-3. getter, setter (마우스 우클릭 -> source -> generate getters and setters)
		(마우스 우클릭 -> source -> generate toString() )
		(마우스 우클릭 -> source -> generate constructor using fields)
- 멤버변수가 은닉된 형태로 선언된 경우 프로그램의 가장 근본적인  목적인
데이터에 접근하는 방법이 사라지므로 메서드를 통한 간접적으로 접근하는
방법이 마련되어야 한다.
- getter, setter는 은닉된 멤버변수에 간접적으로 접근하기 위하여 정의된 
메서드들을 의미하는 용어이다.
	- getter → 은닉된 멤버변수의 값을 리턴하기 위한 메서드
	- setter → 파라미터로 전달된 값을 멤버변수에 복사하기 위한 메서드

String userName
	- getter : String getUserName()
	-setter : void setUserName( String userName )

int userAge
	- getter : int getUserAge()
	-setter : void setUserAge( int userAge )

- get', 'set' 접두사 뒤에 변수 이름을 첫 글자가 대문자인 형태로 명시
- getter는 연결된 멤버변수의 데이터 타입을 리턴형으로 명시
- setter는 연결된 멤버변수의 데이터 타입을 파라미터 형으로 명시

1-4. 클래스에 접근 한정자를 지정한 경우
- public
	-> 객체 생성이 가능하다.
	-> 서로 다른 소스코드에 정의된 클래스끼리도 객체 생성이 가능하다.
- private		-> 클래스에 적용할 수 없다.
- protected	-> 클래스에 적용할 수 없다.
- default
	-> 동일한 소스코드에 정의된 클래스끼리만 객체로 생성 가능하다.
	-> 지금까지의 예제 형태

1-5. 자바빈즈(JavaBeans)
- 자바언어에서 사용하는 복합적인 데이터 표현의 최소 단위로서, 재사용 가능한 
컴포넌트(구성요소)를 생성할 수 있다.
- 자바빈즈 클래스로서 작동하기 위해서, 객체 클래스는 명명법, 생성법 그리고 
행동에 관련된 일련의 관례를 따라야만 한다.

2. 상속성
2-1. 클래스 간의 상속이란?
- 클래스 간에는 부모-자식의 상속 관계를 설정할 수 있다.
- 부모 클래스 A를 자식 클래스 B가 상속 받을때, B는 A의 모든 멤버변수와
메서드를 자신의 것으로 상속받게 된다.
- 상속 가능 여부 : public, protected
- B는 A의 public, protected 기능들을 직접적으로 코딩하지 않더라도 자신의
것으로 사용할 수 있게 된다.

2-2. 상속 정의 방법
- exetends 키워드를 사용하여 부모 클래스의 이름을 명시한다.
	public class 자식클래스 exetends 부모 클래스{...}

2-3. 클래스 다이어그램을 통한 상속 표현
- 클래스의 구조를 표현하는 클래스 다이어그램에서, 상속은 
자식 클래스가 부모 클래스를 가리키는 화살표로 표현한다.
- 상속관계가 이루어질 때 부모 클래스를 super 클래스라 한다.

2-4. 상속의 활용
- 공통 기능을 별도의 클래스로 추출해 내면, 코드의 재사용 및 수정이 
용이하다.

3. 다형성 - Override
3-1. Override란
- 부모 클래스가 갖고 있는 기능을 자식 클래스가 재정의한다.
- 부모 클래스에 정의된 것과 동일한 이름을 갖는 메서드를 자식 클래스가 
정의한 경우, 부모 클래스의 기능은 자식에게 가려진다.
- 이렇게 부모의 기능을 재정의 하는 것을 메서드 Override라 한다.
- 하나의 이름으로 다양한 효과 얻을 수 있다.
- 모든 자식 클래스가 동일한 이름의 메서드를 갖게 되므로 각 객체에 대하여 
attack()이라는 이름을 사용하여 서로 다른 형태를 구현할 수 있게 된다.

3-2. Super 키워드
- 클래스의 상속 관계에서 자식 클래스가 부모 클래스를 가리키는 예약어
- 사용방법
	-> 멤버변수 이름 앞에 명시
	부모 클래스의 멤버변수를 의미한다. 하지만 부모 클래스의 멤버변수는
	이미 모두 상속되어 있기 때문에 이 경우에는 this키워드를 사용하는 
	것과 동일한 결과이기에 잘 사용하지 않는다.
	
	-> 메서드 이름 앞에 명시
	- 부모 클래스의 메서드를 의미한다.
	- 재정의 되지 않은 메서드
		=> 이미 상속되어 있기 때문에 this 키워드를 사용하는 것과
		 동일한 결과를 갖는다.
	- 재정의 된 메서드
		=> Override 된 메서드 이름 앞에 사용하게 되면 재정의되기
		 이전의 원본 메서드를 의미한다.

	-> 키워드 자체를 메서드처럼 사용
		- 부모 클래스의 생성자를 의미한다.
		- super();
		
class Hello{
	public void say(){
		System.out.println("Hello");
	}
}

class Korean extends Hello{
	public void say(){
		System.out.println("안녕하세요");

	}
	public void sayHell(){
		super.say();
		this.say();
	}
}

3-3. 상속 관계에서의 생성자 처리
- 생성자가 정의된 클래스의 상속 제한한다.
- 하지만 생성자가 정의된 클래스는 객체 생성을 위해서 생성자 파라미터를
 반드시 전달받아야 하기 때문에, 파라미터를 갖는 생성자가 정의된 클래스를 
 상속받게 되면 에러가 발생된다.

3-4. 부모 생성자의 강제 호출
- 생성자가 정의된 클래스를 상속받은 경우에는 자식 클래스의 생성자를 
통해서 부모 생성자를 강제로 호출해야 한다.
- 부모의 생성자를 호출하는 방법은 super() 키워드를 메서드 이름으로 
사용하는 것이다.

3-5. @Override 옵션 -> Annotation
- 메서드 재정의 과정에서의 오타 방지 옵션
- @Override는 키워드가 명시된 위치 아래에 정의되는 메서드가 부모 클래스에
존재하지 않을 경우 구문 에러로 처리한다.
- 부모 클래스의 메서드를 재정의 하고자 할 경우 의도치 않은 실수를 예방하기
 위한 '오타 방지 옵션'이다.
- 여러 개의 메서드를 재정의한다면 재정의되는 모든 메서드 위에 각기 
명시해야 한다.

4. 다형성	- 오버로드(Overload)
4-1. 메서드 오버로드
- 원칙적으로 하나의 클래스 안에서는 동일한 이름의 메서드가 두 개 이상 
존재할 수 없지만, 이를 가능하게 하는 예외적인 처리 기법이다.

4-2. 이름이 동일한 메서드를 정의하기 위한 조건
- 메서드 간의 파라미터가 서로 달라야 한다.
	-> 파라미터 데이터 타입이 서로 달라야한다.
	(데이터 형이 동일하고 변수의 이름이 다른 경우는 동일한 파라미터로
	 인식된다.)
	-> 파라미터의 개수가 다르다.
	-> 서로 다른 데이터 형을 갖는 파라미터들의 전달 순서가 다르다.
- 리턴 형이 다른 경우는 오버로드의 성립에 아무런 영향을 주지않는다.

4-3. 오버로드의 예시
- 파라미터의 데이터 형이 서로 다르기 때문에 오버로드 성립된다.
	public void foo( int a ){}
	public void foo( long a ){}

- 파라미터의 개수가 서로 다르기 때문에 오버로드 성립된다.
	public void foo(int a){}
	public void foo(int a, int b){}

- 데이터 형의 전달 순서가 서로 다르기 때문에 오버로드 성립된다.
	public void foo(int a, String b){}
	public void foo(String a, int b){}

- 오버로드 불가
	public int foo( int a )
	public String foo( int x )

4-4. 생성자의 Overload
- 생성자 역시 매서드의 한 종류이므로 Overload가 가능하다.
- 생성자를 Overload할 경우, 해당 클래스에 대해 '객체를 생성하는
방법'을 다양하게 준비할 수 있게 된다.





















1. 변수의 범위(= 변수의 스코프)
 - 자신보다 하위 블록으로는 침투할 수 있다.
 - 사용 가능 예

	int num = 100;
	if( num == 100 ){
		System.out.println(num);
	}

 - 사용 가능 예

	int num = 100;
	for( int i = 0; i<10; i++ ){
		System.out.println(num + i);
 	}
	
 - 자신이 선언된 블록 밖으로는 빠져나갈 수 없다.
 -  사용 불가능 예
	int num = 100;
	if( num == 100 ){
		int result = num+ 100;
	}
	// 변수 result가 if블록 안에서 생성되었으므로 사용불가
	System.out.println(result);

 -  사용 불가능 예
	for( int i = 0; i<10; i++ ){
		...
	}
	// i가 for문을 위한 괄호 안에서 사용되었으므로 사용 불가
	System.out.println(i);

 - 블록안에서 선언된 변수는 블록 밖에서 존재하는 동일한 이름의
 변수와는 이름만 동일할 뿐, 다른 값으로 인식된다.
 - 사용 가능 예
	int target = 100;
	if( target == 100 ){
		int num = target + 100;
	} else {
		int num = target - 100;
	}
	
2. 반복문에서의 break와 continue
 - break : 반복문 안에서 break 키워드를 만나면 반복을 강제로 종료
 - continue : 실행흐름이 증감식으로 강제 이동

3. 배열
 3-1. 배열이란
  - 변수를 그룹으로 묶은 형태의 한 종류로서, 사물함 같은 형태를
  갖고 있다.
  - 하나의 배열안에는 같은 종류(데이터 형)의 값들만 저장 될 수 있다.

 3-2. 배열을 만드는 방법
  - 배열의 선언

	데이터형[] 배열이름;

  - 배열의 생성 : 변수를 저장할 수 있는 사물함을 생성된다.

	배열이름 = new 데이터형[크기];

  - 배열 생성의 예 : 3개의 int형 변수를 저장할 수 있는 배열 생성

	int[] grade;
	grade = new int[3];

  - 배열의 선언과 크기 지정에 대한 일괄처리

	데이터형[] 배열이름 = new 데이터형[크기];
	int[] grade = new int[3];

 3-3. 배열의 모양
  - 생성된 배열은 사물함과 같이 각각의 칸에 값들이 저장되고,
  각각의 칸은 0부터 일련번호가 지정된다.(일련번호 = 배열의 인덱스)

 3-4. 배열에 값을 저장하기
  - 배열은 값을 저장할 수 있는 공간일 뿐, 그 자체가 값은 아니다.
  - 값이 대입되지 않은 경우, 숫자형은 0,  boolean 형은 false가 자동으로
  대입된다.
  - 배열안에 값을 저장하기 위해서는 인덱스 번호를 사용하여 각각의
  칸에 직접 값을 대입해야한다.

	배열이름[인덱스] = 값;

  - 둘리의 점수를 배열로 표현
  
	int[] grade = new int[3];	
	grade[0] = 75;
	grade[1] = 82;
	grade[2] = 91;

 3-5. 배열의 크기 설정과 값 할당에 대한 일괄처리
  - 배열의 크기를 지정하면서 괄호 "{...}" 안에 배열에 포함될 각 항목들을
  콤마(,)로 나열하면, 배열의 생성과 값의 할당을 일괄처리 할 수 있다.
  이때 배열의 별도로 지정하지 않으며, "new 데이터형[]" 부분은 생략 가능
 
	데이터형[] 배열이름 = new 데이터형[]{75, 82, 91};
			혹은
	데이터형[] 배열이름 = {75, 82, 91};

  3-6. 배열값 사용하기
   - 배열안에 저장되어 있는 값들을 사용하여 연산이나 출력등의 처리를
   위해서는 배열에 부여된 인덱스 값을 통해서 데이터에 접근해야한다.
	
	System.out.println( grade[0] );
	System.out.println( grade[1] );
	System.out.println( grade[2] );

 3-7. 배열과반복문
  - 배열의특성
	-> 0 ~ (배열의 크기-1) 만큼의 인덱스 값을 순차적로 갖는다
  
	// 배열의 인덱스는 0부터 전체 길이 3보다 작은 2까지이다.
	int[] grade = new int[]{100,100,90};

	for( int i=0; i<3; i++ ){
		System.out.println(grade[i]);
	}

 3-8. 배열의 크기(길이)
  - 배열의 길이를 얻기 위해서는 "배열이름.length" 형식으로 접근한다.
  - grade라는 배열을 생성한 경우 배열의 길이

 	int size = grade.length;
	-----------------------------------------------------
	int[] grade = new int[]{100,100,90, 80};

	for( int i=0; i<grade.length; i++ ){
		System.out.println(grade[i]);
	}

 3-9. 배열의 종류
  - 1차 배열
	-> 앞에서 살펴본 배열 처럼 한 줄만 존재하는 사물함 같이
	구성된 배열
	-> 행에 대한 개념이 없고, 열에 대한 개념만 존재하기 때문에
	"배열이름.length"는 몇칸이지를 알아보는 기능이 된다.

  - 2차 배열
	-> 1차 배열의 각 칸에 새로운 배열을 넣는 형태
	-> 1차 배열의각 칸은 행이 되고, 각각의칸에 추가된 개별적인
	배열이 "열"의 개념이되어 "행렬"을 구성하게 된다.
  
 3-10. 2차원 배열의 생성 방법
   - 2차원 배열의 선언
  	
	데이터형[][] 배열이름;

  - 2차원 배열의 크기 할당

	배열이름 = new 데이터형[행][열];

  - 2차원 배열의 선언과 할당의 일괄처리

	데이터형[][] 배열이름 = new 데이터형[행][열];

  - 2차원 배열의 선언, 크기할당, 값의 대입에 대한 일괄 처리

	데이터형[][] 배열이름 = new 데이터형[][]{
		{ 0행0열의 값, 0행1열의 값, ..., 0행n열의 값 },
		{ 1행0열의 값, 1행1열의 값, ..., 1행n열의 값 },
		...	
		{ n행0열의 값, n행1열의 값, ..., n행n열의 값 }
	};

  - 2차원 배열에 대한 값의 대입 방법
	-> 행,열에 대한 인덱스를 통하여 값을 대입한다.

	배열이름[행][열] = 값;

 3-11.2차원 배열의 길이
  - 2차원 배열의 길이는 행에 대한 측면과 열에 대한 측면을 나누어서 
  생각해야 한다.
  - 행의 길이
	-> 1차원 배열에서 길이는 2차원 배열에서는 행의 크기로 조회

		int rows = grade.length;

  - 열의 길이
	-> 열의 길이는 각 행에 대해서 개별적으로 조회해야 한다.

		int cols =grade[행].length;
















